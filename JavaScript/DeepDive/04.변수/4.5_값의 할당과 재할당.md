# 변수

앞서 식별자에 대해서 배웠습니다. 배운 내용을 회고하자면, 변수 선언문이 선두로 끌어 올려진 것을 호이스팅이라 한다.

## 4.5 값의 할당

변수에 값을 `할당(assignment, 대입, 저장)`할 때는 할당 연산자 `=` 를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```js
var score; // 변수 선언
score = 80; // 값의 할당
```

- 변수 선언과 값의 할당을 하나의 `문(statement)`로 단축 표현할 수 있다.

```js
var score = 80; // 변수 선언과 값의 할당
```

변수 선언과 값의 할당을 2개의 문으로 나누어 표현한 코드와 변수 선언과 값의 할당을 하나의 문으로 단축 표현한 코드는 정확히 동일한 동작을 한다. 즉, 자바스크립트 엔진은 **변수 선언**과 **값의 할당**을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.

> _**Key Point💡**_
>
> > 변수 선언은 소스코드가 순차적으로 실행된 시점인 런타인 이전에 먼저 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```js
console.log(score); // undefined

var score; // 1. 변수 선언
score = 90; // 2. 값의 할당

console.log(score); // 90
```

- 변수선언(`1`)은 런타임 이전에 먼저 실행되고 값의 할당(`2`)은 런타임에 실행된다. 따라서, score 변수에 값을 할당하는 시점(`2`)에는 이미 변수 선언이 완료된 상태이며 이미 `undefined`로 초기화되어 있다. 따라서, score변수에 값을 할당하면, score 변수의 값은 `undefined`에서 새롭게 할당한 숫자 값 `80`으로 변경(**재할당**)이 된다.

#### 4.5.1. 변수 선언

| 변수이름 (식별자) | 메모리 주소 |  메모리   |
| :---------------: | :---------: | :-------: |
|                   | 0x00000000  |    ...    |
|                   |     ...     |           |
|    **score →**    | 0x000000F2  | undefined |
|                   |     ...     |           |
|                   | 0xFFFFFFFFF |           |

#### 4.5.2. 값의 할당

| 변수이름 (식별자) | 메모리 주소 |  메모리   |
| :---------------: | :---------: | :-------: |
|                   | 0x00000000  |    ...    |
|                   |     ...     |           |
|                   | 0x000000F2  | undefined |
|                   |     ...     |           |
|    **score →**    | 0x00001332  |    80     |
|                   |     ...     |           |
|                   | 0xFFFFFFFFF |           |

- 위의 표처럼 변수에 값을 할당할 때는 이전 값 `undefined`가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값 `80`을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 `확보`하고 그 곳에 할당 값 `80`을 저장하는 것이다.

```js
console.log(score);

score = 80;
var score;

console.log(score);
```

- 이것 처럼 런타임 이전에 가장 먼저 `var score;`가 실행되면서 변수들이 선언이 되었으므로, `score = 80;` 변수선언 코드 이전인 값의 할당 코드가 나와도 에러가 발생하지 않는다.

## 4.6. 값의 재할당

재할당이란, 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

```js
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

`var` 키워드로 선언한 변수는 값의 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다. `var` 키워드로 선언한 변수는 선언과 동시에 `undefined`로 초기화되기 때문에 엄밀히 말하면 변수에 첨으로 값을 할당하는 것도 재할당이다.

재할당은 변수에 저장된 값을 다른 값으로 변경한다. 그래서 변수라고 하는 것이다.

> _**Key Point💡**_
>
> > 만약, **값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)라 한다.**

<br/>

> _**Key Point💡**_
>
> > 상수는 한번 정해지면 변하지 않는 값이다. 다시 말해 상수는 단 한번만 할당할 수있는 변수다.

### 참고) const 키워드

- ES6에 도입된 `const` 키워드를 사용해 서언한 변수는 재항당이 금지 된다. 즉, const 키워드는 단 한번만 할당할 수 있는 변수를 선언한다.
- 따라서, `const` 키워드를 사용하면 상수를 표현할 수 있다.

```js
const foo = 10;

foo = 100; // TypeError
```

- 변수에 값을 재할당하면 `score`변수의 값은 이전 값 `80`에 재할당한 값 `90`으로 변경된다. 처음 값을 할당했을 때와 마찬가지로 이전 값 `80`이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값 90을 새롭게 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장한다.

#### 4.6.1. 변수 선언

```js
var score;
```

| 변수이름 (식별자) | 메모리 주소 |  메모리   |
| :---------------: | :---------: | :-------: |
|                   | 0x00000000  |    ...    |
|                   |     ...     |           |
|    **score →**    | 0x000000F2  | undefined |
|                   |     ...     |           |
|                   | 0xFFFFFFFFF |           |

#### 4.6.2. 값의 할당

```js
score = 80;
```

| 변수이름 (식별자) | 메모리 주소 |  메모리   |
| :---------------: | :---------: | :-------: |
|                   | 0x00000000  |    ...    |
|                   |     ...     |           |
|                   | 0x000000F2  | undefined |
|                   |     ...     |           |
|    **score →**    | 0x00001332  |    80     |
|                   |     ...     |           |
|                   | 0xFFFFFFFFF |           |

#### 4.6.3. 값의 재할당

```js
score = 90;
```

| 변수이름 (식별자) | 메모리 주소 |  메모리   |
| :---------------: | :---------: | :-------: |
|                   | 0x00000000  |    ...    |
|                   |     ...     |           |
|                   | 0x000000F2  | undefined |
|                   |     ...     |           |
|                   | 0x00001332  |    80     |
|                   |     ...     |    ...    |
|    **score →**    | 0x0669F913  |    90     |
|                   |     ...     |           |
|                   | 0xFFFFFFFFF |           |

- 현재 `score` 변수의 값은 90이다. score 변수의 이전 값인 undefined와 80은 어떤 변수도 값으로 갖고 있지 않다. 즉, 어떤 식별자와도 연결되어 있지 않다. 이것은 더이상 `undefined`와 `80`이 필요하지 않다는 것을 의미한다.
- 이렇게 아무도 사용하고 있지 않으니 불필요한 값들은 **가비디 콜렉터**에 의해 메모리에 자동 해제된다.
  - 단 언제 해제가 될지는 예측할 수 없다.

### 참고) 가비지 콜렉터

- 가비지 콜렉터는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다.
- 더이상 사용되지 않는 메모리란, 간단히 말하자면 **어떤 식별자도 참조하지 않는 메모리 공간**을 의미한다.
- 이처럼, 자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로서, 메모리 누수를 방지한다.

### 참고) 언매니지드 언어 vs. 매니지드 언어

- C언어가 대표적으로 언매니지 언어로 개발자가 명시적으로 메모리 할당하고 해제하기 위해 `malloc()`과 `free()`같은 저수준 메모리 제어 기능을 제공한다.
- 자바스크립트는 메모리 관리 기능을 언어차원에서 담당하기에 개발자의 직접적인 메모리 제어를 허용하지 않는다.
  - 즉, 개발자가 명시적으로 메모리를 할당하고 해제할 수 는 없다.
  - 더이상 사용하지 않는 메모리의 해제느 ㄴ가비지 콜렉터가 수행한다.

## 요약

- 변수에 값을 `할당(assignment, 대입, 저장)`할 때는 할당 연산자 `=` 를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.
- 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다.
- `var`와 `let`은 재할당이 가능하다.
- 상수는 한번 정해지면 변하지 않는 값이다. 다시 말해 상수는 단 한번만 할당할 수있는 변수다.
- 상수의 대표적인 키워드로는 `const`이다.
- 아무도 사용하고 있지 않은 메모리 공간에 대해서 **가비디 콜렉터**에 의해 메모리에 자동 해제된다.
